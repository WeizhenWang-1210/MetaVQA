"""
This script is designed for manually placing assets into a static scene within the MetaDrive environment.
It is intended to serve as demo purpose

The primary class, 'AssetAdjuster', manages the loading of objects, user interaction for object placement, and saving
of layout configurations.

Methods:
- __init__: Initializes the AssetAdjuster with environment configuration, folder paths, and save paths.
- load_json_file: Static method to load a JSON file.
- process_folder: Initiates the process of adjusting assets in a folder.
- load_and_display_objects: Loads and displays objects using previously saved meta information.
- add_same_asset: Adjusts parameters for the same asset, allowing placement of new instances of same object.
- spawn_object: Spawns an object in the environment with specified parameters.
- load_saved_values: Loads saved values for a specific asset.
- onlyStep: Just step without place new object, might also capture screenshot
- adjust_parameters: Adjusts location and orientation for a new placed object.
- process_next: Processes the next asset in the list for adjustment.
- go_to_next_asset: Skips to the next asset, discarding adjustments for the current one.
- save_to_json: Saves the adjusted parameters to a JSON file.
"""
import vqa.vqagen.utils.qa_utils
from metadrive.envs.metadrive_env import MetaDriveEnv
from metadrive.component.static_object.test_new_object import TestObject, TestGLTFObject
from asset.read_config import configReader
import os
import json
import tkinter as tk
import math
class AssetAdjuster:
    def __init__(self, env_config, folder_path, save_path):
        """
        Initialize the AssetAdjuster.

        :param env_config: Configuration for the MetaDrive environment.
        :param folder_path: Path to the folder containing asset JSON files generated by objverse_change_asset_script.py
        :param save_path: Path to save the position and other information for each asset placed.
        """
        self.env = MetaDriveEnv(env_config)
        self.folder_path = folder_path
        self.env.reset()
        self.current_obj = None
        self.save_path = save_path
        self.t = 0
        self.load_and_display_objects()
        self.files = [file for file in os.listdir(folder_path) if file.endswith(".json")]
        self.current_index = 0
    @staticmethod
    def load_json_file(filepath):
        """
        Load a JSON file and return its content.

        Parameters:
        - filepath (str): The path to the JSON file to be loaded.

        Returns:
        - dict: A dictionary containing the data loaded from the JSON file.
        """
        with open(filepath, 'r') as f:
            return json.load(f)

    def load_and_display_objects(self):
        """
        Load and display objects using saved meta information.
        If you have previously use this python script to place items.
        This function will be called initially and serve as a "resume game" function
        It will place the asset you have privously placed again.
        """
        if not os.path.exists(self.save_path):
            print(f"Save file '{self.save_path}' does not exist.")
            return

        with open(self.save_path, 'r') as f:
            saved_data = json.load(f)

        for filepath, params_list in saved_data.items():
            asset_metainfo = self.load_json_file(filepath)
            for params in params_list:
                x = params['x']
                y = params['y']
                theta = params['theta']
                if "foldername" in asset_metainfo.keys() and asset_metainfo["foldername"] is not None:
                    self.env.engine.spawn_object(TestGLTFObject, position=[x, y], heading_theta=theta, random_seed=1,
                                                 force_spawn=True, asset_metainfo=asset_metainfo)
                else:
                    self.env.engine.spawn_object(TestObject, position=[x, y], heading_theta=theta, random_seed=1,
                                                 force_spawn=True, asset_metainfo=asset_metainfo)

    def add_same_asset(self, filepath):
        """
        Adjust parameters for adding a new instance of the same asset.

        Parameters:
        - filepath (str): The path to the JSON file of the asset.
        """
        self.adjust_parameters(filepath)
    def spawn_object(self, x, y, theta, asset_metainfo):
        """
        Spawn an object in the environment with specified position and rotation.

        Parameters:
        - x (float): X position of the object.
        - y (float): Y position of the object.
        - theta (float): Rotation angle of the object in radians.
        - asset_metainfo (dict): Metadata about the asset, used for spawning.
        """
        if self.current_obj is not None:
            self.env.engine.clear_objects([self.current_obj.id], force_destroy=True)
        if "foldername" in asset_metainfo.keys() and asset_metainfo["foldername"] is not None:
            self.current_obj = self.env.engine.spawn_object(TestGLTFObject, position=[x, y], heading_theta=theta,
                                                            random_seed=1, force_spawn=True,
                                                            asset_metainfo=asset_metainfo)
        else:
            self.current_obj = self.env.engine.spawn_object(TestObject, position=[x, y], heading_theta=theta,
                                                            random_seed=1, force_spawn=True,
                                                            asset_metainfo=asset_metainfo)

    def load_saved_values(self, filepath):
        """
        Load saved position and orientation values for a specific asset.

        Parameters:
        - filepath (str): Path to the asset's JSON file.

        Returns:
        - dict: A dictionary containing the last saved values for the asset. If no values are saved, returns an empty dictionary.
        """
        output_filename = self.save_path
        if os.path.exists(output_filename):
            with open(output_filename, 'r') as f:
                data = json.load(f)
            # Get the last set of values for this filepath, or an empty dictionary if none exists
            return vqa.vqagen.utils.qa_utils.get(filepath, [{}])[-1]
        return {}
    def onlyStep(self, capture=False, pic_name_id=1):
        """
        Onle execute steps in the environment (without adjust additional object) and optionally capture screenshots.

        Parameters:
        - capture (bool): If True, captures screenshots of the environment.
        - pic_name_id (int): Identifier used to name the captured image files.
        """
        step = 0
        while True:
            o, r, tm, tc, info = self.env.step([0, 0])
            if capture:
                self.env.capture("spawned{}_obj_{}.jpg".format(pic_name_id, step))
            step += 1
    def adjust_parameters(self, filepath):
        """
        Adjust parameters of an asset using a GUI interface. Allows for manual positioning and rotation of the asset.

        Parameters:
        - filepath (str): Path to the JSON file of the asset.
        """
        asset_metainfo = self.load_json_file(filepath)
        saved_values = self.load_saved_values(filepath)

        def on_scale_change(val, entry):
            entry.delete(0, tk.END)
            entry.insert(0, val)
            x = x_scale.get()
            y = y_scale.get()
            theta = theta_scale.get()
            self.spawn_object(x, y, theta, asset_metainfo)

        def on_entry_change(entry, scale):
            try:
                scale_val = float(vqa.vqagen.utils.qa_utils.get())
                scale.set(scale_val)
            except ValueError:
                pass  # You may want to provide a user feedback about invalid input
        def update_env():
            self.t = self.t + 1
            o, r, tm, tc, info = self.env.step([0, 0])
            # self.env.capture("spawned_obj_{}.jpg".format(self.t))
            root.after(50, update_env)  # Calls itself every 50 milliseconds. Adjust this interval as needed.


        root = tk.Tk()
        root.title("Adjust parameters for " + filepath)

        def on_submit():
            x_val = x_scale.get()
            y_val = y_scale.get()
            theta_val = theta_scale.get()
            self.save_to_json(x_val, y_val, theta_val, filepath)
            self.current_obj = None  # Prevent clearing the object when spawning next
            root.destroy()

        def on_submit_and_next():
            on_submit()
            self.current_index += 1
            self.process_next()

        def on_submit_and_add_same():
            on_submit()
            # No need to increment the current_index
            self.process_next()

        submit_and_next_btn = tk.Button(root, text="Submit and Next", command=on_submit_and_next)
        submit_and_next_btn.pack(pady=20)

        submit_and_add_same_btn = tk.Button(root, text="Submit and Add Same", command=on_submit_and_add_same)
        submit_and_add_same_btn.pack(pady=20)

        next_asset_btn = tk.Button(root, text="Next Asset", command=lambda: self.go_to_next_asset(root))
        next_asset_btn.pack(pady=20)
        x_default = saved_values.get('x', 10)
        y_default = saved_values.get('y', -5)
        theta_default = saved_values.get('theta', 0)

        x_scale = tk.Scale(root, from_=-100, to=100, orient=tk.HORIZONTAL, length=300, sliderlength=30)
        x_scale.set(x_default)
        x_scale.pack(pady=20)

        x_entry = tk.Entry(root)
        x_entry.insert(0, x_scale.get())
        x_entry.bind('<Return>', lambda e: on_entry_change(x_entry, x_scale))
        x_scale.config(command=lambda val: on_scale_change(val, x_entry))
        x_entry.pack(pady=10)

        y_scale = tk.Scale(root, from_=-50, to=50, orient=tk.HORIZONTAL, length=300, sliderlength=30)
        y_scale.set(y_default)
        y_scale.pack(pady=20)

        y_entry = tk.Entry(root)
        y_entry.insert(0, y_scale.get())
        y_entry.bind('<Return>', lambda e: on_entry_change(y_entry, y_scale))
        y_scale.config(command=lambda val: on_scale_change(val, y_entry))
        y_entry.pack(pady=10)

        theta_scale = tk.Scale(root, from_=-math.pi, to=math.pi, orient=tk.HORIZONTAL, label="Heading Theta", length=300, sliderlength=30, resolution=0.01)
        theta_scale.set(theta_default)
        theta_scale.pack(pady=20)

        theta_entry = tk.Entry(root)
        theta_entry.insert(0, theta_scale.get())
        theta_entry.bind('<Return>', lambda e: on_entry_change(theta_entry, theta_scale))
        theta_scale.config(command=lambda val: on_scale_change(val, theta_entry))
        theta_entry.pack(pady=10)

        update_env()  # Start the loop to update the environment
        root.mainloop()

    def process_next(self):
        """
        Process the next asset in the list for adjustment. This method moves sequentially through a list of assets,
        allowing for their individual adjustment.
        """
        if self.current_index < len(self.files):
            print("================Dealing with: {}".format(self.files[self.current_index]))
            self.adjust_parameters(os.path.join(self.folder_path, self.files[self.current_index]))

    def process_folder(self):
        """
        Initiates the process of adjusting assets in a folder.
        This method serves as the starting point for batch processing assets for adjustment.
        """
        self.process_next()
    def go_to_next_asset(self, root):
        """
        Skip to the next asset in the list, bypassing the current one.

        Parameters:
        - root (tk.Tk): The Tkinter root window, used for GUI interactions.
        """
        if self.current_obj is not None:
            self.env.engine.clear_objects([self.current_obj.id], force_destroy=True)
        self.current_obj = None
        root.destroy()
        self.current_index += 1
        self.process_next()

    def save_to_json(self, x, y, theta, filepath):
        """
        Save the adjusted position and orientation parameters of an asset to a JSON file.

        Parameters:
        - x (float): Adjusted X position of the object.
        - y (float): Adjusted Y position of the object.
        - theta (float): Adjusted rotation angle of the object in radians.
        - filepath (str): Path to the JSON file where the adjusted parameters will be saved.
        """
        output_filename = self.save_path
        if os.path.exists(output_filename):
            with open(output_filename, 'r') as f:
                data = json.load(f)
        else:
            data = {}

        # Check if this filepath already exists in the data
        if filepath not in data:
            data[filepath] = []

        data[filepath].append({
            'x': x,
            'y': y,
            'theta': theta
        })

        # Write updated data back to the JSON file
        with open(output_filename, 'w') as f:
            json.dump(data, f, indent=4)



if __name__ == "__main__":
    env_config = {
        "num_scenarios": 1,
        "traffic_density": 0.6,
        "traffic_mode": "hybrid",
        "start_seed": 35,
        "debug": False,
        "cull_scene": False,
        "manual_control": True,
        "use_render": True,  # Set your render value here
        "decision_repeat": 5,
        "need_inverse_traffic": True,
        "rgb_clip": True,
        "render_pipeline": True,
        "map": "XCrRC",
        "random_traffic": True,
        "random_lane_width": True,
        "driving_reward": 1.0,
        "force_destroy": False,
        "window_size": (2400, 1600),
        "vehicle_config": {
            "enable_reverse": True,
            "show_navi_mark": False,
        },
        "traffic_vehicle_config": {
            "show_navi_mark": False,
            "show_dest_mark": False,
            "enable_reverse": False,
            "show_lidar": False,
            "show_lane_line_detector": False,
            "show_side_detector": False,
        },
    }
    config = configReader()

    path_config = config.loadPath()
    asset_folder_path = path_config["assetfolder"]
    folder_path = path_config["adj_parameter_folder"]
    save_path = os.path.join(path_config["layout_static_info_folder"], "spawn_object2.json")
    adjuster = AssetAdjuster(env_config, folder_path, save_path)
    # call process folder if you want to place new items
    # adjuster.process_folder()
    # call onlystep if you just want to see current scene and take screenshot
    adjuster.onlyStep(capture=True, pic_name_id=2)
