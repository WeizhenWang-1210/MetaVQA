{
    "generic":{
        "localization":{
            "text": [
                "Locate the <o>.",
                "Give me the bounding [box] of <o>."
            ],
            "params":[
                "<o>",
                "box"
            ],
            "end_filter":"locate",
            "constraint":[]
        },
        "counting": {
            "text":[
                "How many <o> are <a>?", 
                "Give me the number of <o> that are <a>"
            ],
            "params":[
                "<o>","<a>"
            ],
            "end_filter":"count",
            "constraint":[]
        },
        "count_equal_binary":{
            "text":[
                "Are there equal number of the following things: <o1>,<o2>?",
                "Do we have the same number of <o1> and <o2>?"
            ],
            "params":[
                "<o1>","<o2>"
            ],
            "end_filter":"count_equal",
            "constraint":[]
        },
        "count_more_binary":{
            "text":[
                "Are there more <o1> than <o2>",
                "Are there less <o2> than <o1>"
            ],
            "params":[
                "<o1>","<o2>"
            ],
            "end_filter":"count_more",
            "constraint":[]
        },
        "identify_property":{
            "text":[
                "What is the <p> for <o>?",
                "What <p> does <o> have"
            ],
            "param":[
                "<p>","<o>","<ans>"
            ],
            "end_filter":"extract_p",
            "constraint":["unique"]
        }
    },
    "dynamic":{
        "identify_stationary":{
            "text":[
                "Is the <o> stationary?",
                "Is the <o> parked?",
                "Is the <o> not moving?"
            ],
            "param":[
                "o"
            ],
            "end_filter":"is_stationary",
            "constraint":["unique"]
        }
    },
    "safety":{
        "feasibility":{
            "text":[
                "Can <o> <a> at this moment?",
                "Is it safe for <o> to <a> at this moment?"
            ],
            "param":[
                "<o>", "<a>"
            ],
            "end_filter":"situational",
            "constraint": ["unique"]
        },
        "regulatory":{
            "text":[
                "Should <o> <a> at this moment?",
                "Does <o> <a> break the traffic rule?",
                "Can <o> <a> without breaking the traffic rule?",
                "Is <o> doing <a> compliant with the traffic rule?"
            ],
            "param":[
                "<o>","<a>"
            ],
            "end_filter":"situational_rule",
            "constraint":["unique"]
        },
        "counterfactual_unary":{
            "text":[
                "Will <e> happen if <o1> <a1>?",
                "If <o> <a>, is <e> expected?"
            ],
            "param":[
                "<o>","<a>"
            ],
            "end_filter":"inference",
            "constraint":["unique"]
        },
        "counterfactual_binary":{
            "text":[
                "If <o1> <a1> and <o2> <a2>, will <e> happens?",
                "Is <e> expected should <o1> <a1> and <o2> <a2>"
            ],
            "param":[
                "<o1>","<a1>, <o2>, <a2>"
            ],
            "constraint":["unique"]
        },
        "counterfactual_unary_choice":{
            "text":[
                "What will happen if <o1> <a1>?"
            ],
            "param":[
                "<o>","<a>","<ans>"
            ],
            "constraint":["unique"]
        },
        "counterfactual_binary_choice":{
            "text":[
                "If <o1> <a1> and <o2> <a2>, what will happens?",
                "What's expected should <o1> <a1> and <o2> <a2>"
            ],
            "param":[
                "<o1>","<a1>", "<o2>", "<a2>","<ans>"
            ],
            "constraint":["unique"]
        }
    }
   
}


<o> car    [[type = car, color = None, pos = None]]
<o> blue car [[type = car, color = blue, pos = None]]
<o> blue car on the right of a green car [[type = car, color=  gree, pos = None], [type = car, color =blue, pos = right]]
<o> parked blue car to the right or the green car that just passed by us

<o> blue c arin front of us

<a> 


 #TODO
dictionary 
<sportscar> := []
    ================
    |             |
  ego  --- v1     |
     \       \    |
      \       \   |
       v2  ---- v3
 
<o> := <s> <p> <t> <dir> <a>| us
<s> := nil | visible | parked | moving | accelerating | decelerating | turning       #depend only on the internal state of that object
<a> := nil | <deed_with_o> <o> | <deed_without_o>
<deed_with_o>:= follow | pass by | collide | head toward | drive alongside 
<deed_without_o>:= turning right | turning left
<p> := nil | red | yellow |blue ..etc..
<t> := anything| car | policecar ..etc...
<dir> := nil | <dir> <o> | left | right | front | back ...


<o> := <t> | <P> <o> | <p> <o> <pos> <o>| <action> <o> <dest> | <o> that <action>
<dest> := <dir> <o>
<action> :=  <deed> | <deed> <o>


<action> := park | accelerate | decelerate | 
<t> : = t|car | pedestrian | policecar  | firefightertruct .....


car  <o>
      |   \   \   \   \
      <s>  <p> <t> <dir> <a> 
      nil  nil  nil  car  nil 

blue car  <o>
           |   \   \   \   \
           <s>  <p> <t> <dir> <a>
           nil  nil  blue  car  nil 


blue car on the right of a green car 
<o>
|   \   \   \   \
<s>  <p> <t> <dir> <a> 
nil  blue  car   |    nil
                 |  \
              <dir> <o>
    on the right of  |   \   \   \   \
                    <s>  <p> <t> <dir> <a>
                    nil  nil  green  car  nil 

[[nil, blue, nil, right] [nil, green, nil, nil]]

parked blue car to the right of the green car that just passed by black sedan
<o>
|   \   \   \   \
<s>  <p> <t> <dir> <a>     [s = park, coloor = blue, type = car, dir = ? , action = none]
park blue  car   |    nil                                   A
                 |  \                                       |  right
              <tdir> <o>        [s = None, color = None, type = car, dir = none, action = ?]
    to the right of  |   \   \   \   \                                                   \
                    <s>  <p> <t> <dir> <a>                                                \
                    nil  green  car  none \    \                                           \ pass by
                                    <deed_with_o>  <o>                                   [s = None, color = black, type = sedan, dir = none, action = none]
                                            |        \
                                     just passed by   <s>  <p> <t> <dir> <a>
                                                      nil  black  sedan none none
            
[s = park, coloor = blue, type = car, dir = right , action = none], [s = None, color = None, type = car, dir = none, action = pass by], [s = None, color = black, type = sedan, dir = none, action = none]
"Locate the <stuff>"



#TODO:
1. Tree Generator: #Done
        INPUT1: The set of all existing terminal symbols in the currect annotation
        INPUT2: Maximum Tree Depth
        Ouput: All cfg Tree utilizing only terminal symbols from INPUT1 with depth at most INPUT2
2.  Tree-Function Translator:
        INPUT1: A cfg Tree
        Output: A configuration file for the functional program that will return nodes satisfying the specified description

3. Tree-English Translator:
        INPUT1: A cfg Tree
        Ouput: The English equivalent description of this cfg Tree, with proper grammar

4. Functional Programs:
        Filter functions that check for specified conditions:
            egs: acclerating_filter_func: lambda x: return x.speed_later > x.speed_current
            egs: heading_toward_fun: lambda x, y: return x will collide with y if x.heading remain the same
            etc...
5. End_filter functions:
        A collection of functions such that:
            INPUT: A set of nodes
            Output: Desired answer

            egs: Count: output the number of elements in the set
                extract_p: extract property p of elements in the set ####NOTE THAT inthis particular question there's a unique constriant,
                meaning that the set S mush satisfy |S| = 1

6. Cache:
    key: A tuple of functional program config and the associated graph
    value: The answer node set























<stuff> : <color> <object>  {x,y| x in color, y  in type}
          <color> <object> <pos> {x,y,z | x  in color, y in type, z in pos0}

<stuff> context-free-grammar -> parse tree -> instantitate concrete descriptions
       <o>  |  <o> := <a> <p> <t> <dir>
       <a> | terminal symbolx


car <o>                        blue car <o>                                 blue car on the right of a gree car  <o>
     |                                  / \                                                                      /\    \      \
    <t>                             <p>    <o>                                                                  <p> <o> <pos> <o> ---------------|                          
     |                               |       |                                                                  blue  |   to the right of       <p> <o>
    car                              blue   <t>                                                                       <t>                       green car
                                            |                                                                         car
                                            car                                                          
                                            
                                               
parked blue car to the right of the green car that just passed by us <o>                                                                
                                                                    / | \                                                                
                                                              <action><o>  <dest>
                                                              /       / \     |    \             
                                                        <deed>      <p><o>    <dir> <o>
                                                          /           |  |       |      \__________           
                                                     park          blue <t>  to the right of      |   |   \
                                                                        |                      <o> that <action>
                                                                        car                    / \          /   \
                                                                                              <p> <o>     <deed>  <o>
                                                                                               /    \         |       \
                                                                                             green   <t>    pass by    <t>
                                                                                                      |                  \
                                                                                                    car                   us                


[<deed> <p> <t> <dir>]
(parked) blue car to the right of [the] green car [that] [just] (passed) by us 

park   blue car to the right of 
<deed> <p> <t> <dir> | <p> <t> <deed> | <t>
                               |
                      green car pass by   us
the process is to generate a parse tree. 

[[type = car, color = blue, action = park, dir = right],  [type = car, color = green, action = pass by, dir = None],[type = us, ...]]



<a> <p ><o> <dir> <>




blue car that turned right?



#TODO : Action injection + recording 
#TODO : Dictionary mapping codename to natural English
#TODO:  



How to instantiate all possible questions:
    go through the dictionary, extract all existing terminal symbols. When instantiating questions, only use terminal symbols that's 
    present in the annotation,
    Use some sort of caching mechanism, so that once it's determined that certain kinds of entities doesn't exist in the scenario,
            key: paths to some entities
            value: unsat.
    Utilize the full potential of context-free-grammar to build trees, and arbitrarily instantiate the tree with terminal tokens. Pass
    this tree to the querier to see if there're some entities that satisfy this description. If so, instantiate the question. If not, 
    remember this cfg with unsat property. 





equal number of blue car and red pedestrian 

blue car---------->     equal ?  ------> True/False
red pedestrian --------> 










